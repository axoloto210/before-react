## Before React
フロントエンドの各ライブラリ・フレームワークでのUIの作成方法やデータの流れの方向性の違いを確認できます。

- Vanilla JavaScript
- jQuery
- Backbone.js
- Knockout.js
- Angular.js
- React.js


## Vanilla JS
JavaScript のみで実装した場合には、以下のような欠点がある。
- ボタンの状態を様々な箇所で操作可能であるため、状態を追跡するのが難しい
- テストを独立に行うことが難しい
- 複数のsource of truth
- 実装上の懸念
  - イベントリスナーをclean up するタイミングをどうするか？
  - 同じidの要素が追加されないか？
  - 要素が確実に存在するか？

## JQuery
Vanilla JSに比べてDOM操作が簡潔になっている。
また、Ajaxなども扱いやすいが、VanillaJS での欠点の他に、以下のような欠点を抱えている。
- モダンブラウザではquerySelector やfetch が標準実装されているため現代では冗長
- ライブラリ読み込みが必要で、パフォーマンス上の懸念がある
- 引き続き独立したテストは難しい

上記の欠点を補うため、Backbone.js との併用がされていた。

## Backbone.js
MVC アーキテクチャを採用している。
以下のように関心の分離ができることが利点。

Model: データとアプリケーションのビジネスロジック（特定の業務や目的を達成するための核心となるロジックやルールのことで、システム固有の処理）

View: UI

Controller: Model とView の橋渡し。命令的。

また、MVC で分離されているため、jQuery やVanillaJS での実装に比べてテストが容易になっている。

以下のような欠点を抱えている。
- 複雑なインタラクティビティと状態管理が困難であること
  - 複雑なUIを実現しようとして、複数のController がview を制御することとなり、競合が起こることがある。
- 双方向データバインディング
  - View とModel の状態を同期させる必要があるが、双方向から同期ができるため意図しない副作用が発生しやすい。
  - Backbone.jsでは、デフォルトで双方向データバインディングの機能が組み込まれていないため自前で管理する必要がある。
  - Model, View, Controller の分離ルールが強制されていないため、破綻しうる。
- 密結合による変更困難性
  - Model, View, Controller はしばしば密結合になってしまい、変更が難しくなる。

## Knockout.js
MVVC アーキテクチャを採用している（Angular.js やVue.jsもMVVM を採用している）。

View-Model: ModelとViewの橋渡し。Controllerとは異なり、Modelにのみ依存する（Viewについては関知しない）。

Viewでのデータの変更は自動的にView-Modelに反映される（逆も然り）。

（React はこのMVVM に単方向データフローという改良を加えているのである。）

欠点として以下を抱えている。
- ボイラープレートが多い
- ViewModel は巨大化・複雑化しやすく、リファクタリングやパフォーマンス最適化が困難となりうる
  - 巨大なViewModel は可読性・テスト容易性も乏しいものとなってしまう
